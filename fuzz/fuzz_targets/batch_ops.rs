#![no_main]

use arbitrary::{Arbitrary, Unstructured};
use libfuzzer_sys::fuzz_target;
use rkvs::namespace::{BatchMode, Namespace};
use rkvs::NamespaceConfig;
use std::sync::Arc;

// Define maximum sizes to prevent the fuzzer from allocating too much memory.
const MAX_KEY_SIZE: usize = 256;
const MAX_VALUE_SIZE: usize = 4096;
const MAX_BATCH_SIZE: usize = 128; // Max items in a single batch operation.

/// A helper struct to generate a key-value pair with controlled sizes.
#[derive(Debug, Arbitrary)]
struct FuzzKv {
    #[arbitrary(with = |u: &mut Unstructured| {
        let size = u.int_in_range(0..=MAX_KEY_SIZE)?;
        u.bytes(size).map(|b| b.to_vec())
    })]
    key: Vec<u8>,
    #[arbitrary(with = |u: &mut Unstructured| {
        let size = u.int_in_range(0..=MAX_VALUE_SIZE)?;
        u.bytes(size).map(|b| b.to_vec())
    })]
    value: Vec<u8>,
}

/// A helper struct to generate just a key with a controlled size.
#[derive(Debug, Arbitrary)]
struct FuzzKey {
    #[arbitrary(with = |u: &mut Unstructured| {
        let size = u.int_in_range(0..=MAX_KEY_SIZE)?;
        u.bytes(size).map(|b| b.to_vec())
    })]
    key: Vec<u8>,
}

/// Define the batch operations we want to fuzz.
/// `rkvs::BatchMode` can be derived directly by `Arbitrary`.
#[derive(Debug, Arbitrary)]
enum FuzzBatchOperation {
    SetMultiple {
        #[arbitrary(with = |u: &mut Unstructured| u.arbitrary_iter::<FuzzKv>()?.take(MAX_BATCH_SIZE).collect::<Result<_,_>>())]
        items: Vec<FuzzKv>,
        #[arbitrary(with = |u: &mut Unstructured| if u.arbitrary()? { Ok(BatchMode::AllOrNothing) } else { Ok(BatchMode::BestEffort) })]
        mode: BatchMode,
    },
    GetMultiple {
        #[arbitrary(with = |u: &mut Unstructured| u.arbitrary_iter::<FuzzKey>()?.take(MAX_BATCH_SIZE).collect::<Result<_,_>>())]
        keys: Vec<FuzzKey>,
        #[arbitrary(with = |u: &mut Unstructured| if u.arbitrary()? { Ok(BatchMode::AllOrNothing) } else { Ok(BatchMode::BestEffort) })]
        mode: BatchMode,
    },
    DeleteMultiple {
        #[arbitrary(with = |u: &mut Unstructured| u.arbitrary_iter::<FuzzKey>()?.take(MAX_BATCH_SIZE).collect::<Result<_,_>>())]
        keys: Vec<FuzzKey>,
        #[arbitrary(with = |u: &mut Unstructured| if u.arbitrary()? { Ok(BatchMode::AllOrNothing) } else { Ok(BatchMode::BestEffort) })]
        mode: BatchMode,
    },
    ConsumeMultiple {
        #[arbitrary(with = |u: &mut Unstructured| u.arbitrary_iter::<FuzzKey>()?.take(MAX_BATCH_SIZE).collect::<Result<_,_>>())]
        keys: Vec<FuzzKey>,
        #[arbitrary(with = |u: &mut Unstructured| if u.arbitrary()? { Ok(BatchMode::AllOrNothing) } else { Ok(BatchMode::BestEffort) })]
        mode: BatchMode,
    },
}

fuzz_target!(|operations: Vec<FuzzBatchOperation>| {
    // We need a Tokio runtime to execute our async functions.
    let rt = tokio::runtime::Builder::new_current_thread()
        .enable_all()
        .build()
        .unwrap();

    rt.block_on(async {
        // Create a new namespace for each fuzzing run to ensure isolation.
        let config = NamespaceConfig::default();
        config.set_max_value_size(MAX_VALUE_SIZE);
        let ns = Arc::new(Namespace::new("fuzz_batch_ns".to_string(), config));

        // Execute the sequence of batch operations generated by the fuzzer.
        for op in operations {
            match op {
                FuzzBatchOperation::SetMultiple { items, mode } => {
                    // Convert Vec<FuzzKv> to Vec<(Vec<u8>, Vec<u8>)>
                    let batch_items = items.into_iter().map(|item| (item.key, item.value)).collect();
                    // We only care about panics/crashes, so we ignore the result.
                    let _ = ns.set_multiple_bytes(batch_items, mode).await;
                }
                FuzzBatchOperation::GetMultiple { keys, mode } => {
                    // Convert Vec<FuzzKey> to Vec<Vec<u8>>
                    let batch_keys: Vec<Vec<u8>> = keys.into_iter().map(|k| k.key).collect();
                    let _ = ns.get_multiple_bytes(batch_keys, mode).await;
                }
                FuzzBatchOperation::DeleteMultiple { keys, mode } => {
                    // Convert Vec<FuzzKey> to Vec<Vec<u8>>
                    let batch_keys: Vec<Vec<u8>> = keys.into_iter().map(|k| k.key).collect();
                    let _ = ns.delete_multiple_bytes(batch_keys, mode).await;
                }
                FuzzBatchOperation::ConsumeMultiple { keys, mode } => {
                    // Convert Vec<FuzzKey> to Vec<Vec<u8>>
                    let batch_keys: Vec<Vec<u8>> = keys.into_iter().map(|k| k.key).collect();
                    let _ = ns.consume_multiple_bytes(batch_keys, mode).await;
                }
            }
        }

        // Optional: Add some final state assertions.
        // This helps catch logical errors, not just crashes.
        let metadata = ns.get_metadata().await;
        let final_count = ns.get_shard_key_counts().await.iter().sum();
        assert_eq!(
            metadata.key_count(),
            final_count,
            "Metadata key_count should match the sum of shard key counts"
        );
    });
});