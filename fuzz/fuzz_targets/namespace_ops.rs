#![no_main]

use arbitrary::{Arbitrary, Unstructured};
use libfuzzer_sys::fuzz_target;
use rkvs::namespace::Namespace;
use rkvs::NamespaceConfig;
use std::sync::Arc;

// Define a maximum size for keys and values to prevent the fuzzer
// from allocating too much memory and slowing down execution.
const MAX_KEY_SIZE: usize = 256;
const MAX_VALUE_SIZE: usize = 4096;

// Define the operations we want to fuzz. `arbitrary` will randomly
// generate instances of this enum.
#[derive(Debug, Arbitrary)]
enum FuzzOperation {
    Set {
        #[arbitrary(with = |u: &mut Unstructured| {
            let size = u.int_in_range(0..=MAX_KEY_SIZE)?;
            u.bytes(size).map(|b| b.to_vec())
        })]
        key: Vec<u8>,
        #[arbitrary(with = |u: &mut Unstructured| {
            let size = u.int_in_range(0..=MAX_VALUE_SIZE)?;
            u.bytes(size).map(|b| b.to_vec())
        })]
        value: Vec<u8>,
    },
    Get {
        #[arbitrary(with = |u: &mut Unstructured| {
            let size = u.int_in_range(0..=MAX_KEY_SIZE)?;
            u.bytes(size).map(|b| b.to_vec())
        })]
        key: Vec<u8>,
    },
    Delete {
        #[arbitrary(with = |u: &mut Unstructured| {
            let size = u.int_in_range(0..=MAX_KEY_SIZE)?;
            u.bytes(size).map(|b| b.to_vec())
        })]
        key: Vec<u8>,
    },
    Consume {
        #[arbitrary(with = |u: &mut Unstructured| {
            let size = u.int_in_range(0..=MAX_KEY_SIZE)?;
            u.bytes(size).map(|b| b.to_vec())
        })]
        key: Vec<u8>,
    },
    Update {
        #[arbitrary(with = |u: &mut Unstructured| {
            let size = u.int_in_range(0..=MAX_KEY_SIZE)?;
            u.bytes(size).map(|b| b.to_vec())
        })]
        key: Vec<u8>,
        #[arbitrary(with = |u: &mut Unstructured| {
            let size = u.int_in_range(0..=MAX_VALUE_SIZE)?;
            u.bytes(size).map(|b| b.to_vec())
        })]
        value: Vec<u8>,
    },
    Exists {
        #[arbitrary(with = |u: &mut Unstructured| {
            let size = u.int_in_range(0..=MAX_KEY_SIZE)?;
            u.bytes(size).map(|b| b.to_vec())
        })]
        key: Vec<u8>,
    },
}

// The main fuzz target macro. `libFuzzer` will call this function
// repeatedly with random data.
fuzz_target!(|operations: Vec<FuzzOperation>| {
    // We need a Tokio runtime to execute our async functions.
    let rt = tokio::runtime::Builder::new_current_thread()
        .enable_all()
        .build()
        .unwrap();

    rt.block_on(async {
        // Create a new namespace for each fuzzing run to ensure isolation.
        // We set a max_value_size to match our arbitrary generation limit.
        let config = NamespaceConfig::default();
        config.set_max_value_size(MAX_VALUE_SIZE);
        let ns = Arc::new(Namespace::new("fuzz_ns".to_string(), config));

        // Execute the sequence of operations generated by the fuzzer.
        for op in operations {
            match op {
                FuzzOperation::Set { key, value } => {
                    // We ignore the result because we are only looking for panics/crashes.
                    // The `set_bytes` function already has checks for value size.
                    let _ = ns.set_bytes(&key, value).await;
                }
                FuzzOperation::Get { key } => {
                    let _ = ns.get_bytes(&key).await;
                }
                FuzzOperation::Delete { key } => {
                    let _ = ns.delete_bytes(&key).await;
                }
                FuzzOperation::Consume { key } => {
                    let _ = ns.consume_bytes(&key).await;
                }
                FuzzOperation::Update { key, value } => {
                    let _ = ns.update_bytes(&key, value).await;
                }
                FuzzOperation::Exists { key } => {
                    let _ = ns.exists_bytes(&key).await;
                }
            }
        }

        // Optional: Add some final state assertions.
        // For example, ensure key_count is not wildly incorrect.
        let metadata = ns.get_metadata().await;
        let final_count = ns.get_shard_key_counts().await.iter().sum();
        assert_eq!(metadata.key_count(), final_count, "Metadata key_count should match the sum of shard key counts");
    });
});
